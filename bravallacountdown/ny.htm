<!DOCTYPE html>
<html>
<head>
  <title>Bråvalla Countdown - The countdown has started</title>
  
  <!-- Custom css -->
  <link rel="stylesheet" href="css/bravallacountdown.css">

  <!-- Jquery -->
  <script src="jquery/jquery-2.1.4.min.js"></script>

  <!-- Bootstrap -->
  <link rel="stylesheet" href="bootstrap/bootstrap.min.css">
  <link rel="stylesheet" href="bootstrap/bootstrap-theme.min.css">
  <script src="bootstrap/bootstrap.min.js"></script>

  <script type="text/javascript" src="instafeed/instafeed.js"></script>
  <style type="text/css">
    #instafeed_ugly img {
      border: 2px solid red;
    }
  </style>

</head>
<body>

  <div id="top" style="height:77px; border-bottom:solid; border-color:#edeeee;border-width:1px">
    <center style="padding-top:25px">Time to Bråvalla 2016 : long long long ;)</center>
  </div>

  <div class="container">
    <div class="row" id="instafeed"></div>
  </div>

  <div id="instafeed_ugly"></div>
  <canvas id="canvas" style="display:none"></canvas>




  <script type="text/javascript">


    // * * *
    // "Main"

    // Global variables,
    var grid_size       = 80;
    var images_valid    = 0;
    var images_invalid  = 0;
    var total_images    = 0;
    var first_run       = 1;
    //var tags_to_fetch   = [2013, 2013, 2013];
    var tags_to_fetch   = [2013, 2014, 2015, ""].sort(function() { return 0.5 - Math.random() });
    var verbose         = 1;
    var slots_all       = new Array();

    // Initialize grid,
    logger("Constructing a grid of "+grid_size+" thumbnails.");
    for (i = 0; i < grid_size; i++) {
      var thumb  = '<div class="col-xs-12 col-sm-2 col-md-2 col-lg-2">'
          thumb += '  <div class="thumbnail text-center scaling">'
          thumb += '    <strong id="caption_'+i+'"></strong>'
          thumb += '    <div class="spinner" id="spinner_'+i+'"/>'
          thumb += '      <a href="#" id="link_'+i+'" target="_blank">'
          thumb += '        <img id="thumb_'+i+'" src="#" class="fade" style="display:none;width:90%">'
          thumb += '      </a>'
          thumb += '    </div>'
          thumb += '  </div>'
          thumb += '</div>'

        $("#instafeed").append(thumb);
        slots_all.push($('#spinner_'+i));
    }

    slots_all.sort(function() { return 0.5 - Math.random() });
    logger(slots_all);

    var slots_per_tag = grid_size / tags_to_fetch.length;
    var slots_for_tag = new Array();

      for (tag = 0; tag < tags_to_fetch.length; tag++){
        slots_for_tag[tags_to_fetch[tag]] = new Array;
        for (slot = 0; slot < slots_per_tag; slot++){
          slots_for_tag[tags_to_fetch[tag]].push(slots_all[slot]);
          slots_all.splice(slot,1);
        }
      }

logger(slots_for_tag);


    // * * *
    // Function definitions,


    // Function for fetching images from instagram with instafeed.
    // Using our own function for inserting the results into the dom since we want
    // to do some "validation" of the images before inserting them.
    //
    // Arguments : Tag to fetch.
    // Returns   : Doesn't return in that sense.
    //
    function fetch_images_from_insta(tag){
      logger("Fetching images from instagram for tag '"+tag+"'");

      // Create the instafeed,
      var feed = new Instafeed({
            get       : 'tagged',                           // Get images that are "tagged",
            tagName   : tag,                                // The actual tag to get,
            clientId  : 'eb01b1b10b72457ea650f74f756bde4a', // The instadeveloper client id,
            mock      : 'true',                             // Don't automatically inject received pictures into the dom,
            limit     : grid_size / tags_to_fetch.length,   // Fetch equally amount of images for each tag,

            // Define custom function for when the instafeed success
            success   : function(instafeed_return) {
              for (i=0; i < instafeed_return.data.length; i++) {
                validate_image(instafeed_return.data[i],feed);
              }
            },

            // FIXME
            error : function() {
            },
        });

      // Execute the feed,
      feed.run();
    }




    // Function for getting an "free slot" from the grid.
    //
    // Arguments : None.
    // Returns   : Slot id if there is one, 0 otherwise.
    //
    function get_free_slot(){

      // Get all the spinner-classes that are visible (slots in the grid),
      var slots = $(".spinner:visible");

      // If we have "free slots" we return a random,
      if (slots.length > 0){
        var rand = Math.floor((Math.random() * slots.length));
        return $(slots[rand]).attr("id").replace("spinner_","");
      }

      // No free slots,
      return 0;
    }




    // Function for adding the instagram image information to the slot
    //
    // Arguments : instaafeed image data object.
    // Returns   : Doesn't really return in that sense.
    //
    function add_image_to_row (image_data){

      // Get all slots and check so we haven't already added the image, this can
      // happen with if people tag their images with multiple tags. However I
      // think that I've got a fix for this.
      var slots = $(".spinner");
      for (var i = 0; i < slots.length; i++) {
        var url = $("#link_"+i).attr("href");
        if (image_data.link == url){
          logger("Not adding image since its already added "+image_data.link);
          return;
        }
      }

      // Get a "free slot" from the grid,
      var free_slot_num = get_free_slot();

      // Do an extra check so the slot isn't really taken. Seems to be some fishy
      // race-condition here. Need to figure this one out.
      if ($("#thumb_"+free_slot_num).attr("src") == "#"){
        // Create a date object with the date from the image and stringify it,
        var newtime = new Date(image_data.created_time * 1000)
        var created = newtime.toDateString()

        // Add the relevant image information to the free slot,
        $("#caption_"+free_slot_num).text(created);
        $("#thumb_"+free_slot_num).attr("src", image_data.images.thumbnail.url);
        $("#thumb_"+free_slot_num).show();
        $("#spinner_"+free_slot_num).hide();
        $("#link_"+free_slot_num).attr("href", image_data.link);
        return;
      }

      console.log("Not adding image to slot since it already has been filled.");
    }




    // Function for validating the picture gotten from instafeed,
    //
    // Arguments : instaafeed image data object, instafeed object)
    // Returns   : Doesn't really return in that sense.
    //
    function validate_image(image_data, feed){
        logger("Validating image "+image_data.images.thumbnail.url);

        // Create new image,
        var img = new Image();

        // Add the eventlistener so we can paint the canvas when the image is ready,
        img.addEventListener("load", function() {

        // Draw the picture in the canvas element,
        var context = document.getElementById('canvas').getContext('2d');
            context.drawImage(img, 0, 0);

        // Get a rectangle 10 pixels wide from top to bottom, and from top left to
        // right,
        var pix_left_to_bottom = context.getImageData(0, 0, 10, canvas.height).data;
        var pix_top_to_right   = context.getImageData(0, 0, canvas.width, 10).data;

        // Loop the pixels from the rectangles, if there is to much white we
        // *could be* dealing with a white frame, simply skip that image.
        // 500 is value that seems to do what I want, feel free to improve
        // this part though. We get some false positives, but I can live with that.
        var probably_white_border = 0;
        for (var i = 0, n = pix_left_to_bottom.length; i < n; i += 4) {
          if (pix_left_to_bottom[i] > 250){
            probably_white_border++;
          }
        }

        for (var i = 0, n = pix_top_to_right.length; i < n; i += 4) {
          if (pix_top_to_right[i] > 250){
            probably_white_border++;
          }
        }

        // Create a date object with the date from the image and stringify it,
        var newtime = new Date(image_data.created_time * 1000)
        var created = newtime.toDateString()
        var year = feed.options.tagName.match(/\d+$/);
        var wrong_year = 0;

        if (year){
          logger("Tag "+feed.options.tagName+" contains year '"+year+"'")
          if (created.indexOf(year) === -1){
            logger("Date "+created+" doesn't match the year of the tag ("+feed.options.tagName+")");
            wrong_year++;
          }
        }else{
          logger("No year in tag, skip check");
        }

        // Invalidate image,
        if (probably_white_border > 1000 || wrong_year === 1){
          images_invalid++;
          logger("Invalidated ("+images_invalid+") image for tag "+feed.options.tagName+" "+image_data.images.thumbnail.url);

          if (verbose){
            var img_invalid  = '<br><br><br>';
                img_invalid  = '<strong> Invalidated Pictures</strong>';
                img_invalid  = '<a href="'+probably_white_border+'">'
                img_invalid += '  <img src="'+image_data.images.thumbnail.url+'">'
                img_invalid += '</a>'
            $("#instafeed_ugly").append(img);
          }
        }else{
          // Image is "all good", lets add it,



          add_image_to_row(image_data);
          images_valid++;
          logger("Validated ("+images_valid+") image for tag "+feed.options.tagName+" "+image_data.images.thumbnail.url);
        }

        // Add up images,
        total_images = images_valid + images_invalid;

        // If total images equals the grid_size and the first_run is set, it means
        // that we have fetched images once for each tag. Now, we most probably
        // haven't filled the grid (since we are invalidating a lot of pictures) so
        // we need to a way of filling the invalidated images, we do this by just
        // calling the "fill_invalidated_images_slots" (which will call feed.next) on the last
        // picture for the last tag until we have no empty slots left.
        if (total_images === grid_size && first_run === 1){
          images_valid   = 0;
          images_invalid = 0;
          first_run      = 0;
          fill_invalidated_images_slots(feed);
        }else if (total_images === grid_size / tags_to_fetch.length ){
          images_valid   = 0;
          images_invalid = 0;
          fill_invalidated_images_slots(feed);
        }

      }, false);

      // Set crossorigin and the src of the image,
      img.crossOrigin="anonymous";
      img.src = image_data.images.thumbnail.url;
    }




    // Function for filling invalidated images slots,
    //
    // Arguments : instafeed object)
    // Returns   : Doesn't really return in that sense.
    //
    function fill_invalidated_images_slots(feed){
      if (get_free_slot() > 0){
           var free_slots = $(".spinner:visible");
           console.log("Still got "+free_slots.length+" slots for "+feed.options.tagName);
           feed.next();
      }
    }




    // Function wrapper for logging to the console,
    //
    // Arguments : Text to print,
    // Returns   : Doesn't return in that sense.
    //
    function logger(text){
      if (verbose){
        console.log(text);
      }
    }




// bind the load more button
//loadButton.addEventListener('click', function() {
//  feed.next();
//});

        // This is sort of a hack just to get pictures tagged with one year
        // only. A lot of people seem to tag pictures with all years, but I
        // want to try to get actual pictures for actual years, so this is
        // way of sorting those pictures out. Of course it's okay to have
        // multiple tags, but just *one* bråvalla[XXXX] tag.
        // if (/bråvalla\d/.test(feed.options.tagName)){
        //   logger("Tag got number in it, lets see so image only has that actual year tag");
        //   logger("Got these tags "+image_data.tags);
        //   var tags = 0;

        //   for (i = 0; i < image_data.tags.length; i++){
        //     logger("Checking tag "+image_data.tags[i]);
        //     if (/bråvalla/.test(image_data.tags[i])){
        //       logger("Tag "+image_data.tags[i]+"matches");
        //       tags++;
        //     }
        //   }

          //if (tags === 1){
          //    logger("Good only one bråvalla number tag "+image_data.tags);
          //}
          // if (/"bråvalla"/.test(){

          // }
          // // If there is only one tag, no need to check.
          // if (image_data.tags.length > 1){

          //   var temp = new Array();
          //   for (i = 0; i < image_data.tags.length; i++){
          //     if (image_data.tags[i].indexOf("bråvalla") > -1){
          //       temp.push(image_data.tags[i]);
          //     }
          //   }
          //   logger("Image contains tags matching bråvalla ("+temp+")");
          //   logger("Looking for tag "+feed.options.tagName);

          //   for (i = 0; i < temp.length; i++){
          //     if (temp[i] === feed.options.tagName){
          //       temp.splice(i, 1)
          //     }
          //   }
          //   logger("Bfter => "+temp.length);
          //   var multiple_tags;
          //   if (temp.length !== 0){
          //     multiple_tags = 1;
          //   }
          //   }
        // }else{
        //   logger(feed.options.tagName+" got no number in tag...");
        // }

</script>

</body>
</html>
